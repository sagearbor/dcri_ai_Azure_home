name: Generate Project Metadata with AI (Batch)

on:
  workflow_dispatch: # Still triggered manually

jobs:
  # Job 1: Read the project list and create a JSON array for the matrix
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      # This output will be a JSON string like '["repo-url-1", "repo-url-2"]'
      repos: ${{ steps.set-matrix.outputs.repos }}
    steps:
      - name: Checkout Landing Page Repo
        uses: actions/checkout@v4

      - name: Generate Matrix from projects.yml
        id: set-matrix
        run: |
          # Use yq (like jq for YAML) to extract all repo URLs into a JSON array
          # The 'yq e' command evaluates, '[.[] | .repo]' creates a proper JSON array
          # The '-o=json -I=0' flags output compact single-line JSON
          echo "repos=$(yq e '[.[] | .repo]' -o=json -I=0 projects.yml)" >> $GITHUB_OUTPUT

  # Job 2: Run the AI generation for each repo in the matrix
  generate-metadata:
    needs: prepare-matrix # This job runs after prepare-matrix is complete
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      models: read
    strategy:
      fail-fast: false # Allows other jobs to continue even if one fails
      matrix:
        # Create a job for each repo URL from the prepare-matrix output
        repo_url: ${{ fromJson(needs.prepare-matrix.outputs.repos) }}
    steps:
      - name: Extract Repository Name
        id: repo-name
        run: |
          # Extract owner/repo from full GitHub URL
          REPO_PATH=$(echo "${{ matrix.repo_url }}" | sed 's|https://github.com/||')
          echo "repo_path=$REPO_PATH" >> $GITHUB_OUTPUT
          
      - name: Checkout Target Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.repo-name.outputs.repo_path }}
          path: 'target-repo'
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Gather Repository Information
        id: gather-info
        run: |
          cd target-repo
          
          # Initialize info variables
          README_CONTENT=""
          PACKAGE_INFO=""
          PROJECT_FILES=""
          
          # Look for README files
          for readme in README.md readme.md README.txt README README.rst; do
            if [ -f "$readme" ]; then
              echo "Found README: $readme"
              README_CONTENT=$(head -50 "$readme" | tr '\n' ' ' | tr '"' "'" | cut -c1-2000)
              break
            fi
          done
          
          # Look for package.json (Node.js projects)
          if [ -f "package.json" ]; then
            PACKAGE_INFO=$(cat package.json | jq -r '{name, description, dependencies, scripts}' 2>/dev/null || echo "")
          fi
          
          # Look for requirements.txt (Python projects)
          if [ -f "requirements.txt" ]; then
            PROJECT_FILES="$PROJECT_FILES Python project with requirements.txt. "
          fi
          
          # Look for other indicators
          if [ -f "Cargo.toml" ]; then
            PROJECT_FILES="$PROJECT_FILES Rust project with Cargo.toml. "
          elif [ -f "go.mod" ]; then
            PROJECT_FILES="$PROJECT_FILES Go project with go.mod. "
          elif [ -f "pom.xml" ]; then
            PROJECT_FILES="$PROJECT_FILES Java project with pom.xml. "
          elif [ -f "composer.json" ]; then
            PROJECT_FILES="$PROJECT_FILES PHP project with composer.json. "
          fi
          
          # Look for deployment/hosting indicators
          DEPLOYMENT_INFO=""
          if [ -f "Dockerfile" ]; then
            DEPLOYMENT_INFO="$DEPLOYMENT_INFO Has Dockerfile for containerization. "
          fi
          if [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ]; then
            DEPLOYMENT_INFO="$DEPLOYMENT_INFO Has docker-compose for multi-service deployment. "
          fi
          if [ -f ".github/workflows/deploy.yml" ] || [ -f ".github/workflows/azure-deploy.yml" ]; then
            DEPLOYMENT_INFO="$DEPLOYMENT_INFO Has GitHub Actions deployment workflow. "
          fi
          if [ -f "azure-pipelines.yml" ]; then
            DEPLOYMENT_INFO="$DEPLOYMENT_INFO Has Azure Pipelines configuration. "
          fi
          
          # Save gathered information
          echo "readme_content=$README_CONTENT" >> $GITHUB_OUTPUT
          echo "package_info=$PACKAGE_INFO" >> $GITHUB_OUTPUT  
          echo "project_files=$PROJECT_FILES" >> $GITHUB_OUTPUT
          echo "deployment_info=$DEPLOYMENT_INFO" >> $GITHUB_OUTPUT

      - name: Prepare AI Prompt
        id: prepare-prompt
        run: |
          cat << 'EOF' > ai_prompt.txt
          STRICT INSTRUCTIONS: You must respond with ONLY a single line of valid JSON. No markdown, no code blocks, no explanations, no additional text.
          
          Generate metadata for this software project. Use EXACTLY this JSON structure (single line, no formatting):
          
          {"name":"PROJECT_NAME","description":"BRIEF_DESCRIPTION","technologies":["TECH1","TECH2","TECH3"],"category":["CAT1","CAT2"],"status":"STATUS","language":["LANG1","LANG2"],"hosted_url":null}
          
          Field requirements:
          - name: Max 50 chars, no quotes in content
          - description: Max 100 chars, no quotes in content, 1-2 sentences
          - technologies: Array of 2-8 tech names (frameworks, languages, tools, databases, cloud services)
          - category: Array of 1-3 categories from: "web-app", "api", "library", "cli-tool", "data-analysis", "dashboard", "chatbot", "research-tool", "medical-app", "automation", "ml-ai", "prototype", "other"
          - status: MUST be one of: "active", "maintenance", "archived"
          - language: Array of programming languages used (primary first)
          - hosted_url: Set to null (will be added when deployed)
          
          Repository: ${{ matrix.repo_url }}
          README: ${{ steps.gather-info.outputs.readme_content }}
          Package: ${{ steps.gather-info.outputs.package_info }}
          Files: ${{ steps.gather-info.outputs.project_files }}
          Deployment: ${{ steps.gather-info.outputs.deployment_info }}
          
          RESPOND WITH ONLY THE JSON LINE. NO OTHER TEXT.
          EOF

      - name: Generate Metadata with AI
        id: generate-metadata
        run: |
          # Use GitHub Models API to generate metadata
          echo "Calling GitHub Models API..."
          
          # Read and properly escape the prompt content
          PROMPT_CONTENT=$(cat ai_prompt.txt | jq -Rs .)
          
          # Create the JSON payload properly
          PAYLOAD=$(jq -n \
            --arg model "gpt-4o-mini" \
            --argjson prompt "$PROMPT_CONTENT" \
            '{
              "model": $model,
              "messages": [
                {
                  "role": "user",
                  "content": $prompt
                }
              ],
              "max_tokens": 500
            }')
          
          echo "Sending payload to API..."
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.PERSONAL_ACCESS_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            "https://models.inference.ai.azure.com/chat/completions")
          
          # Log the response for debugging
          echo "API Response: $RESPONSE"
          
          # Extract the generated JSON from the response
          RAW_CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content' 2>/dev/null || echo '{"error":"API_failed"}')
          
          echo "AI response: $RAW_CONTENT"
          
          # Clean the response (remove any whitespace/newlines)
          METADATA=$(echo "$RAW_CONTENT" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
          
          # Validate it's valid JSON
          if echo "$METADATA" | jq . > /dev/null 2>&1; then
            echo "‚úÖ Valid JSON: $METADATA"
          else
            echo "‚ùå Invalid JSON from AI, using fallback"
            REPO_NAME=$(basename "${{ matrix.repo_url }}")
            METADATA="{\"name\":\"$REPO_NAME\",\"description\":\"Auto-generated metadata\",\"technologies\":[\"unknown\"],\"category\":\"other\",\"status\":\"active\",\"language\":\"unknown\"}"
          fi
          
          # Save the metadata (properly escaped for GitHub Actions)
          echo "metadata<<EOF" >> $GITHUB_OUTPUT
          echo "$METADATA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Also save to file for debugging
          echo "$METADATA" > generated_metadata.json

      - name: Preserve Hosted URLs and Create project-meta.json File
        run: |
          cd target-repo
          
          # Check if project-meta.json already exists and preserve hosted_url
          EXISTING_HOSTED_URL="null"
          if [ -f "project-meta.json" ]; then
            EXISTING_HOSTED_URL=$(jq -r '.hosted_url // "null"' project-meta.json 2>/dev/null || echo "null")
            echo "Found existing hosted_url: $EXISTING_HOSTED_URL"
          fi
          
          # Get AI-generated metadata
          AI_METADATA='${{ steps.generate-metadata.outputs.metadata }}'
          
          # Preserve existing hosted_url if it's not null, otherwise use AI-generated value
          if [ "$EXISTING_HOSTED_URL" != "null" ] && [ "$EXISTING_HOSTED_URL" != "" ]; then
            echo "Preserving existing hosted_url: $EXISTING_HOSTED_URL"
            FINAL_METADATA=$(echo "$AI_METADATA" | jq --arg url "$EXISTING_HOSTED_URL" '.hosted_url = $url')
          else
            FINAL_METADATA="$AI_METADATA"
          fi
          
          # Create the project-meta.json file
          echo "$FINAL_METADATA" > project-meta.json
          
          # Validate it's valid JSON
          if ! jq . project-meta.json > /dev/null 2>&1; then
            echo "Generated invalid JSON, creating fallback metadata"
            REPO_NAME=$(basename "${{ matrix.repo_url }}")
            CURRENT_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            cat << EOF > project-meta.json
          {
            "name": "$REPO_NAME",
            "description": "Repository from ${{ matrix.repo_url }}",
            "technologies": ["unknown"],
            "category": "other",
            "status": "active",
            "language": "unknown",
            "generated_by": "github-actions",
            "generated_at": "$CURRENT_DATE"
          }
          EOF
          fi
          
          echo "Created project-meta.json:"
          cat project-meta.json

      - name: Commit Generated File Directly
        run: |
          cd target-repo
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          # Add and commit the file
          git add project-meta.json
          
          # Only commit if there are changes
          if ! git diff --cached --quiet; then
            git commit -m "Add project-meta.json for project hub integration

            ü§ñ Generated with GitHub Actions from repository analysis"
            
            # Push directly to main branch
            git push origin HEAD:main
            echo "‚úÖ Successfully committed project-meta.json to ${{ matrix.repo_url }}"
          else
            echo "‚ÑπÔ∏è No changes to commit for ${{ matrix.repo_url }}"
          fi