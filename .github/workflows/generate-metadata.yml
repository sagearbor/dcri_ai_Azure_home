name: Generate Project Metadata with AI (Batch)

on:
  workflow_dispatch: # Still triggered manually

jobs:
  # Job 1: Read the project list and create a JSON array for the matrix
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      # This output will be a JSON string like '["repo-url-1", "repo-url-2"]'
      repos: ${{ steps.set-matrix.outputs.repos }}
    steps:
      - name: Checkout Landing Page Repo
        uses: actions/checkout@v4

      - name: Generate Matrix from projects.yml
        id: set-matrix
        run: |
          # Use yq (like jq for YAML) to extract all repo URLs into a JSON array
          # The 'yq e' command evaluates, '[.[] | .repo]' creates a proper JSON array
          # The '-o=json -I=0' flags output compact single-line JSON
          echo "repos=$(yq e '[.[] | .repo]' -o=json -I=0 projects.yml)" >> $GITHUB_OUTPUT

  # Job 2: Run the AI generation for each repo in the matrix
  generate-metadata:
    needs: prepare-matrix # This job runs after prepare-matrix is complete
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      models: read
    strategy:
      fail-fast: false # Allows other jobs to continue even if one fails
      matrix:
        # Create a job for each repo URL from the prepare-matrix output
        repo_url: ${{ fromJson(needs.prepare-matrix.outputs.repos) }}
    steps:
      - name: Extract Repository Name
        id: repo-name
        run: |
          # Extract owner/repo from full GitHub URL
          REPO_PATH=$(echo "${{ matrix.repo_url }}" | sed 's|https://github.com/||')
          echo "repo_path=$REPO_PATH" >> $GITHUB_OUTPUT
          
      - name: Checkout Target Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.repo-name.outputs.repo_path }}
          path: 'target-repo'
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Gather Repository Information
        id: gather-info
        run: |
          cd target-repo
          
          # Initialize info variables
          README_CONTENT=""
          PACKAGE_INFO=""
          PROJECT_FILES=""
          
          # Look for README files
          for readme in README.md readme.md README.txt README README.rst; do
            if [ -f "$readme" ]; then
              echo "Found README: $readme"
              README_CONTENT=$(head -50 "$readme" | tr '\n' ' ' | tr '"' "'" | cut -c1-2000)
              break
            fi
          done
          
          # Look for package.json (Node.js projects)
          if [ -f "package.json" ]; then
            PACKAGE_INFO=$(cat package.json | jq -r '{name, description, dependencies, scripts}' 2>/dev/null || echo "")
          fi
          
          # Look for requirements.txt (Python projects)
          if [ -f "requirements.txt" ]; then
            PROJECT_FILES="$PROJECT_FILES Python project with requirements.txt. "
          fi
          
          # Look for other indicators
          if [ -f "Cargo.toml" ]; then
            PROJECT_FILES="$PROJECT_FILES Rust project with Cargo.toml. "
          elif [ -f "go.mod" ]; then
            PROJECT_FILES="$PROJECT_FILES Go project with go.mod. "
          elif [ -f "pom.xml" ]; then
            PROJECT_FILES="$PROJECT_FILES Java project with pom.xml. "
          elif [ -f "composer.json" ]; then
            PROJECT_FILES="$PROJECT_FILES PHP project with composer.json. "
          fi
          
          # Look for deployment/hosting indicators
          DEPLOYMENT_INFO=""
          if [ -f "Dockerfile" ]; then
            DEPLOYMENT_INFO="$DEPLOYMENT_INFO Has Dockerfile for containerization. "
          fi
          if [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ]; then
            DEPLOYMENT_INFO="$DEPLOYMENT_INFO Has docker-compose for multi-service deployment. "
          fi
          if [ -f ".github/workflows/deploy.yml" ] || [ -f ".github/workflows/azure-deploy.yml" ]; then
            DEPLOYMENT_INFO="$DEPLOYMENT_INFO Has GitHub Actions deployment workflow. "
          fi
          if [ -f "azure-pipelines.yml" ]; then
            DEPLOYMENT_INFO="$DEPLOYMENT_INFO Has Azure Pipelines configuration. "
          fi
          
          # Save gathered information
          echo "readme_content=$README_CONTENT" >> $GITHUB_OUTPUT
          echo "package_info=$PACKAGE_INFO" >> $GITHUB_OUTPUT  
          echo "project_files=$PROJECT_FILES" >> $GITHUB_OUTPUT
          echo "deployment_info=$DEPLOYMENT_INFO" >> $GITHUB_OUTPUT

      - name: Gather Git Activity Metrics  
        id: git-metrics
        run: |
          cd target-repo
          
          # Get current date for calculations
          CURRENT_DATE=$(date -u +%Y-%m-%d)
          THIRTY_DAYS_AGO=$(date -u -d '30 days ago' +%Y-%m-%d)
          NINETY_DAYS_AGO=$(date -u -d '90 days ago' +%Y-%m-%d)
          
          # Count commits in last 30 days
          COMMITS_30D=$(git rev-list --count --since="$THIRTY_DAYS_AGO" HEAD 2>/dev/null || echo "0")
          
          # Count commits in last 90 days  
          COMMITS_90D=$(git rev-list --count --since="$NINETY_DAYS_AGO" HEAD 2>/dev/null || echo "0")
          
          # Get last commit date
          LAST_COMMIT=$(git log -1 --format=%ci 2>/dev/null || echo "unknown")
          LAST_COMMIT_DATE=$(echo "$LAST_COMMIT" | cut -d' ' -f1)
          
          # Count unique contributors in last 90 days
          CONTRIBUTORS=$(git shortlog -sn --since="$NINETY_DAYS_AGO" 2>/dev/null | wc -l || echo "0")
          
          # Count releases/tags in last 90 days
          RECENT_RELEASES=$(git tag --sort=-creatordate --merged HEAD 2>/dev/null | head -10 | while read tag; do
            TAG_DATE=$(git log -1 --format=%ci "$tag" 2>/dev/null | cut -d' ' -f1)
            if [[ "$TAG_DATE" > "$NINETY_DAYS_AGO" ]]; then
              echo "$tag"
            fi
          done | wc -l || echo "0")
          
          # Calculate days since last commit
          if [[ "$LAST_COMMIT_DATE" != "unknown" ]]; then
            DAYS_SINCE_COMMIT=$(( ( $(date -u -d "$CURRENT_DATE" +%s) - $(date -u -d "$LAST_COMMIT_DATE" +%s) ) / 86400 ))
          else
            DAYS_SINCE_COMMIT=999
          fi
          
          # Calculate hotness score (0-100)
          # Factors: recent commits (40%), contributor count (20%), recency (30%), releases (10%)
          COMMIT_SCORE=$((COMMITS_30D > 20 ? 40 : COMMITS_30D * 2))
          CONTRIBUTOR_SCORE=$((CONTRIBUTORS > 5 ? 20 : CONTRIBUTORS * 4))
          RECENCY_SCORE=$((DAYS_SINCE_COMMIT < 7 ? 30 : DAYS_SINCE_COMMIT < 30 ? 20 : DAYS_SINCE_COMMIT < 90 ? 10 : 0))
          RELEASE_SCORE=$((RECENT_RELEASES > 2 ? 10 : RECENT_RELEASES * 5))
          HOTNESS_SCORE=$((COMMIT_SCORE + CONTRIBUTOR_SCORE + RECENCY_SCORE + RELEASE_SCORE))
          
          echo "Git Activity Metrics:"
          echo "Commits (30d): $COMMITS_30D"
          echo "Commits (90d): $COMMITS_90D" 
          echo "Last commit: $LAST_COMMIT_DATE"
          echo "Days since commit: $DAYS_SINCE_COMMIT"
          echo "Contributors: $CONTRIBUTORS"
          echo "Recent releases: $RECENT_RELEASES"
          echo "Hotness score: $HOTNESS_SCORE"
          
          # Save metrics
          echo "commits_30d=$COMMITS_30D" >> $GITHUB_OUTPUT
          echo "commits_90d=$COMMITS_90D" >> $GITHUB_OUTPUT
          echo "last_commit=$LAST_COMMIT_DATE" >> $GITHUB_OUTPUT
          echo "days_since_commit=$DAYS_SINCE_COMMIT" >> $GITHUB_OUTPUT
          echo "contributors=$CONTRIBUTORS" >> $GITHUB_OUTPUT
          echo "recent_releases=$RECENT_RELEASES" >> $GITHUB_OUTPUT
          echo "hotness_score=$HOTNESS_SCORE" >> $GITHUB_OUTPUT

      - name: Prepare AI Prompt
        id: prepare-prompt
        run: |
          cat << 'EOF' > ai_prompt.txt
          STRICT INSTRUCTIONS: You must respond with ONLY a single line of valid JSON. No markdown, no code blocks, no explanations, no additional text.
          
          Generate metadata for this software project. Use EXACTLY this JSON structure (single line, no formatting):
          
          {"name":"PROJECT_NAME","description":"BRIEF_DESCRIPTION","technologies":["TECH1","TECH2","TECH3"],"category":["CAT1","CAT2"],"status":"STATUS","language":["LANG1","LANG2"],"hosted_url":null,"activity":{"commits_30d":N,"last_commit":"YYYY-MM-DD","contributors":N,"hotness_score":N}}
          
          Field requirements:
          - name: Max 50 chars, no quotes in content
          - description: Max 100 chars, no quotes in content, 1-2 sentences
          - technologies: Array of 2-8 tech names (frameworks, languages, tools, databases, cloud services)
          - category: Array of 1-3 categories from: "web-app", "api", "library", "cli-tool", "data-analysis", "dashboard", "chatbot", "research-tool", "medical-app", "automation", "ml-ai", "prototype", "other"
          - status: MUST be one of: "active", "maintenance", "archived"
          - language: Array of programming languages used (primary first)
          - hosted_url: Set to null (will be added when deployed)
          - activity: Object with git metrics (use the provided values exactly)
          
          Repository: ${{ matrix.repo_url }}
          README: ${{ steps.gather-info.outputs.readme_content }}
          Package: ${{ steps.gather-info.outputs.package_info }}
          Files: ${{ steps.gather-info.outputs.project_files }}
          Deployment: ${{ steps.gather-info.outputs.deployment_info }}
          Git Activity: commits_30d=${{ steps.git-metrics.outputs.commits_30d }}, last_commit=${{ steps.git-metrics.outputs.last_commit }}, contributors=${{ steps.git-metrics.outputs.contributors }}, hotness_score=${{ steps.git-metrics.outputs.hotness_score }}
          
          RESPOND WITH ONLY THE JSON LINE. NO OTHER TEXT.
          EOF

      - name: Generate Metadata with AI
        id: generate-metadata
        continue-on-error: true
        run: |
          # Use GitHub Models API to generate metadata
          echo "Calling GitHub Models API..."
          
          # Read and properly escape the prompt content
          PROMPT_CONTENT=$(cat ai_prompt.txt | jq -Rs .)
          
          # Create the JSON payload properly
          PAYLOAD=$(jq -n \
            --arg model "gpt-4o-mini" \
            --argjson prompt "$PROMPT_CONTENT" \
            '{
              "model": $model,
              "messages": [
                {
                  "role": "user",
                  "content": $prompt
                }
              ],
              "max_tokens": 500
            }')
          
          echo "Sending payload to API..."
          
          # Add timeout and better error handling
          HTTP_CODE=$(curl -s -w "%{http_code}" -o response.json -X POST \
            --max-time 30 \
            --retry 2 \
            --retry-delay 5 \
            -H "Authorization: Bearer ${{ secrets.PERSONAL_ACCESS_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            "https://models.inference.ai.azure.com/chat/completions")
          
          echo "HTTP Status Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" -eq 200 ]; then
            RESPONSE=$(cat response.json)
            echo "API Response: $RESPONSE"
          else
            echo "API call failed with status $HTTP_CODE"
            echo "Response body: $(cat response.json)"
            
            # Use fallback metadata for failed API calls
            echo "‚ö†Ô∏è GitHub Models API unavailable, generating basic metadata from repository analysis"
            REPO_NAME=$(basename "${{ matrix.repo_url }}")
            
            # Create basic metadata from what we know
            BASIC_METADATA="{\"name\":\"$REPO_NAME\",\"description\":\"Auto-generated from repository analysis\",\"technologies\":[\"unknown\"],\"category\":[\"other\"],\"status\":\"active\",\"language\":[\"unknown\"],\"hosted_url\":null,\"activity\":{\"commits_30d\":0,\"last_commit\":\"unknown\",\"contributors\":0,\"hotness_score\":0}}"
            RESPONSE='{"choices":[{"message":{"content":"'$BASIC_METADATA'"}}]}'
          fi
          
          # Extract the generated JSON from the response
          RAW_CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content' 2>/dev/null || echo '{"error":"API_failed"}')
          
          echo "AI response: $RAW_CONTENT"
          
          # Clean the response (remove any whitespace/newlines)
          METADATA=$(echo "$RAW_CONTENT" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
          
          # Validate it's valid JSON
          if echo "$METADATA" | jq . > /dev/null 2>&1; then
            echo "‚úÖ Valid JSON: $METADATA"
          else
            echo "‚ùå Invalid JSON from AI, using fallback"
            REPO_NAME=$(basename "${{ matrix.repo_url }}")
            METADATA="{\"name\":\"$REPO_NAME\",\"description\":\"Auto-generated metadata\",\"technologies\":[\"unknown\"],\"category\":[\"other\"],\"status\":\"active\",\"language\":[\"unknown\"],\"hosted_url\":null,\"activity\":{\"commits_30d\":0,\"last_commit\":\"unknown\",\"contributors\":0,\"hotness_score\":0}}"
          fi
          
          # Save the metadata (properly escaped for GitHub Actions)
          echo "metadata<<EOF" >> $GITHUB_OUTPUT
          echo "$METADATA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Also save to file for debugging
          echo "$METADATA" > generated_metadata.json

      - name: Preserve Hosted URLs and Create project-meta.json File
        run: |
          cd target-repo
          
          # Check if project-meta.json already exists and preserve hosted_url
          EXISTING_HOSTED_URL="null"
          if [ -f "project-meta.json" ]; then
            EXISTING_HOSTED_URL=$(jq -r '.hosted_url // "null"' project-meta.json 2>/dev/null || echo "null")
            echo "Found existing hosted_url: $EXISTING_HOSTED_URL"
          fi
          
          # Get AI-generated metadata  
          AI_METADATA='${{ steps.generate-metadata.outputs.metadata }}'
          
          # Inject real git metrics into the AI-generated metadata
          FINAL_METADATA=$(echo "$AI_METADATA" | jq \
            --arg commits_30d "${{ steps.git-metrics.outputs.commits_30d }}" \
            --arg last_commit "${{ steps.git-metrics.outputs.last_commit }}" \
            --arg contributors "${{ steps.git-metrics.outputs.contributors }}" \
            --arg hotness_score "${{ steps.git-metrics.outputs.hotness_score }}" \
            '.activity.commits_30d = ($commits_30d | tonumber) | 
             .activity.last_commit = $last_commit | 
             .activity.contributors = ($contributors | tonumber) | 
             .activity.hotness_score = ($hotness_score | tonumber)')
          
          # Preserve existing hosted_url if it's not null
          if [ "$EXISTING_HOSTED_URL" != "null" ] && [ "$EXISTING_HOSTED_URL" != "" ]; then
            echo "Preserving existing hosted_url: $EXISTING_HOSTED_URL"
            FINAL_METADATA=$(echo "$FINAL_METADATA" | jq --arg url "$EXISTING_HOSTED_URL" '.hosted_url = $url')
          fi
          
          # Create the project-meta.json file
          echo "$FINAL_METADATA" > project-meta.json
          
          # Validate it's valid JSON
          if ! jq . project-meta.json > /dev/null 2>&1; then
            echo "Generated invalid JSON, creating fallback metadata"
            REPO_NAME=$(basename "${{ matrix.repo_url }}")
            CURRENT_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            cat << EOF > project-meta.json
          {
            "name": "$REPO_NAME",
            "description": "Repository from ${{ matrix.repo_url }}",
            "technologies": ["unknown"],
            "category": "other",
            "status": "active",
            "language": "unknown",
            "generated_by": "github-actions",
            "generated_at": "$CURRENT_DATE"
          }
          EOF
          fi
          
          echo "Created project-meta.json:"
          cat project-meta.json

      - name: Commit Generated File Directly
        run: |
          cd target-repo
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          # Add and commit the file
          git add project-meta.json
          
          # Only commit if there are changes
          if ! git diff --cached --quiet; then
            git commit -m "Add project-meta.json for project hub integration

            ü§ñ Generated with GitHub Actions from repository analysis"
            
            # Push directly to main branch
            git push origin HEAD:main
            echo "‚úÖ Successfully committed project-meta.json to ${{ matrix.repo_url }}"
          else
            echo "‚ÑπÔ∏è No changes to commit for ${{ matrix.repo_url }}"
          fi